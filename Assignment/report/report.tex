\documentclass{article}

\usepackage{nomencl}
\usepackage{blkarray} % customed arrays
\usepackage{amsmath} % matrix equations
\usepackage{graphicx} % import images
\usepackage{float} % floating imgs
\usepackage{subcaption} % several figures on one line
\graphicspath{ {ressources/} }
\makeglossary

\title{Computational Methods \& C++ Assignment}
\author{Augustin Reille}
\date{2 November 2017}

\begin{document}
    % Title
    \maketitle

    % Abstract
    \begin{abstract}
        A one-space dimensional problem is considered, to examine the application
        of numerical schemes for the solution of partial differential equations. 
    \end{abstract}

    % Table of contents
    \newpage
    \tableofcontents

    % List of figures
    \newpage
    \listoffigures

    % List of tables
    \listoftables

    % List of abbreviations / Nomenclature


    % Introduction
    \newpage
    \section{Introduction}

    
    % Methods / Procedures
    \newpage
    \section{Methods}


        Several methods are used :
        \begin{itemize}
            \item{Dufort-Frankel}
            \item{Richardson}
            \item{Laasonen simple implicit}
            \item{Crank-Nicholson}
        \end{itemize}
        For all of the used schemes, the initialization of the result matrix is run the same way.
        First the study grid must be chosen. The initials conditions are:
        \begin{itemize}
            \item{$T_{int}$ of 100$^{\circ}$F}
            \item{$T_{sur}$ of 300$^{\circ}$F}
            \item{$D = 0.1 ft^{2}/hr$}
        \end{itemize}
        First it was assumed that $\Delta x = 0.05$ and $\Delta t = 0.01$,
        so that the result matrix could be initialized.
        We set:
        \begin{equation}
            n_{space} = \frac{L}{\Delta x} + 1
        \end{equation}
        \begin{equation}
            n_{time} = \frac{T}{\Delta t}
        \end{equation}
        $n_{space}$ is the number of iterations over the grid, according to the coordinate $x$. \\
        $n_{time}$ is the number of iterations over the grid, according to the time $t$. \\
        
        \[
            \begin{blockarray}{cccccc}
            i=0 & i=1 & \cdots & n_{space}-1 & n_{space} \\
            \begin{block}{(ccccc)c}
              T_{ext} & T_{int} & \cdots & T_{int} & T_{ext} & j=0 \\
              T_{ext} & 0 & \cdots & 0 & T_{ext} & j=1 \\
              \vdots & \vdots & \ddots & \vdots & \vdots & \vdots \\
              T_{ext} & 0 & \cdots & 0 & T_{ext} & n_{time} \\
            \end{block}
            \end{blockarray}
        \]
        This is how the matrix is initialized, according to initial conditions.
        For most of the used schemes, we need two previous time steps to calculate the current step.
        An order one scheme is used to find the second line of the matrix:
        \begin{equation}
            T_{i,1} = \frac{\alpha}{2} (T_{i+1,0} + T_{i-1,0}) + (1-\alpha)T_{i,0}
        \end{equation}
        with $$\alpha = 2\frac{D\delta t}{\delta x^{2}}$$
        So we have:
        \[
            \begin{blockarray}{cccccc}
            i = 0 & i = 1 & \cdots & n_{space}-1 & n_{space} \\
            \begin{block}{(ccccc)c}
              T_{ext} & T_{int} & \cdots & T_{int} & T_{ext} & j=0 \\
              T_{ext} & T_{i,1} & \cdots & T_{i,1} & T_{ext} & j=1 \\
              \vdots & \vdots & \ddots & \vdots & \vdots & \vdots \\
              T_{ext} & 0 & \cdots & 0 & T_{ext} & n_{time} \\
            \end{block}
            \end{blockarray}
        \]
        With this trick our matrix is ready to be used and filled up with every scheme.

        \subsection{Explicit schemes}
            For both of the explicit schemes used (Dufort-Frankel and Richardson schemes), the solving
            is run the same way : with a double for-loop, the matrix is filled up. The only thing that change
            is the way we advance in time and space.

            \subsubsection{Dufort-Frankel}
                Explicitly, for Dufort-Frankel method, we have:
                \begin{equation}
                    T_{j}^{n+1} = (\frac{1-\alpha}{1+\alpha})T_{j}^{n-1} + (\frac{\alpha}{1+\alpha})(T_{j+1}^{n}+T_{j-1}^{n})
                \end{equation}
                with $$\alpha = 2\frac{D\delta t}{\delta x^{2}}$$

            \subsubsection{Richardson}
                Explicitly, for Richardson method, we have:
                \begin{equation}
                    T_{j}^{n+1} = T_{j}^{n-1} + \alpha (T_{j-1}^{n} - 2T_{j}^{n} + T_{j+1}^{n})
                \end{equation}
                with $$\alpha = 2\frac{D\delta t}{\delta x^{2}}$$

        \subsection{Implicit schemes}

                For both implicit schemes, the vector solution is given by a matrix equation. A $LU$
                factorization is used once, before a for-loop, to resolve the system for each space step.

                \subsubsection{Laasonen}

                We have :
                \begin{equation}
                    \frac{T_{j}^{n+1} - T_{j}^n}{\Delta t} = D \frac{T_{j+1}^{n+1}- 2T_{j}^{n+1} + T_{j-1}^{n+1}}{\Delta x^2}
                \end{equation}

                Written in a matrical way, the solution at space step $n+1$ is given by :
                \begin{equation}
                    \begin{bmatrix}
                        1+2C   & -C     & 0      & \cdots & 0 \\
                        -C     & 1+2C   & -C     & \ddots & \vdots \\
                        0      & -C     & \ddots & \ddots & 0 \\
                        \vdots & \ddots & \ddots & 1+2C   & -C\\
                        0      & \cdots & 0      & -C     & 1+2C
                    \end{bmatrix}
                    \begin{bmatrix}
                        T_{1} \\
                        T_{2} \\
                        \vdots \\
                        T_{i} \\
                        \vdots \\
                        T_{ntime}
                    \end{bmatrix}_{n+1}
                    =
                    \begin{bmatrix}
                        T_{1} + CT_{0}\\
                        T_{2} \\
                        \vdots \\
                        T_{i} \\
                        \vdots \\
                        T_{ntime} + CT_{f}
                    \end{bmatrix}_{n}
                \end{equation}
                with $$C = \frac{D\Delta t}{\Delta x ^2}  $$ 
                The first vector at space $n$ is our boundaries conditions vector, so it is known.
                In this scheme we must be aware that the right-term vector is actually bigger than
                the other, of 2 values, which corresponds to the exterior temperatures, which stays
                the same all the time.\\
                We apply the $LU$ solve algorithm for each space step, at the reduced vector, and add the $n+1$ vector to our 
                result matrix. The new right term vector is the one found with the $LU$ solve algorithm.
 
                \subsubsection{Crank-Nicholson}
                    We have :
                    \begin{equation}
                        \frac{T_{j}^{n+1} - T_{j}^n}{\Delta t} = D\frac{1}{2} (\frac{T_{j+1}^{n+1}- 2T_{j}^{n+1} + T_{j-1}^{n+1}}{\Delta x^2}+\frac{T_{j+1}^{n}- 2T_{j}^{n} + T_{j-1}^{n}}{\Delta x^2})
                    \end{equation}
                    Written in a matrical way, the solution at space step $n+1$ is given by :
                    \begin{equation}
                        \begin{bmatrix}
                            1+C    & -C/2   & 0     & \cdots & 0 \\
                            -C/2   & 1+C    & -C/2   & \ddots & \vdots \\
                            0      & -C/2   & \ddots & \ddots & 0 \\
                            \vdots & \ddots & \ddots & 1+C   & -C/2\\
                            0      & \cdots & 0      & -C/2   & 1+C
                        \end{bmatrix}
                        \begin{bmatrix}
                            T_{1} \\
                            T_{2} \\
                            \vdots \\
                            T_{i} \\
                            \vdots \\
                            T_{ntime}
                        \end{bmatrix}_{n+1}
                    \end{equation}
                    \[
                        =
                        \begin{bmatrix}
                            1-C    &C/2    & 0      & \cdots & 0 \\
                            C/2     & 1-C   & C/2     & \ddots & \vdots \\
                            0      & C/2     & \ddots & \ddots & 0 \\
                            \vdots & \ddots & \ddots & 1-C   & C/2\\
                            0      & \cdots & 0      & C/2     & 1-C
                        \end{bmatrix}
                        \begin{bmatrix}
                            T_{1} + CT_{0}\\
                            T_{2} \\
                            \vdots \\
                            T_{i} \\
                            \vdots \\
                            T_{ntime} + CT_{f}
                        \end{bmatrix}_{n}
                    \]
                    with $$C = \frac{D\Delta t}{\Delta x ^2}  $$ 
                    The method is the same as Laasonen scheme, except that the left term vector found with the $LU$ solve
                    algorithm is multiplied by the right term matrix before the next space step.

            \subsection{Analytical solution}
                The analytical solution of the problem considered will be used to compare our results and to calculate
            the errors. The result of the analytical solution for a time $t$ and a position $x$ is given by : 
            \begin{equation}
                T = T_{ext}+2(T_{int}-T_{ext})\sum_{m=1}^{m=\infty} e^{-D(m\pi / L)^{2}t} \frac{1-(-1)^m}{m\pi} sin(\frac{m\pi x}{L})
            \end{equation}


            \subsection{Object Oriented Design}

            The object oriented classes for the C++ code are designed the following way :\\
            \begin{figure}[H]
                \includegraphics[width=\textwidth]{UML.png}
                \caption{UML Diagram of the C++ object oriented code}
            \end{figure}
            There is a main base class called PDESolve, which initializes all the variables, and two functions :
            \begin{itemize}
                \item{get\_res() : returns the results Matrix}
                \item{solve() : virtual function which will be overwritten in subclasses}
            \end{itemize}
            There is two subclasses of PDESolve : PDEExplicit and PDEImplicit. Each one has a solve() function, and a virtual advance function,
            which corresponds at the way the space and time steps are incrementded.
            The PDEImplicit class also initializes all the matrixes and functions needed for the LU factorization and solve.
            Each subsubclass, which corresponds to each method, has its own particular advance method.
    % Results
    \newpage
    \section{Results}
        \subsection{Schemes study}
            Note that results from Richardson scheme are not displayed on the following plots, due to its unstability : 
        the incorrect values polluted our charts.
        \begin{figure}[H]
            \includegraphics[width=\textwidth]{t01.png}
            \caption{Results with differents schemes at t = 0,1h}
        \end{figure}
        We can see that except for the Richardson scheme, the results are quite the same. The errors had been calculated 
        to evaluate the accuracy of each method.
        \begin{table}[H]
            \centering
            \caption{Errors for different schemes at t = 0,1h}
            \begin{tabular}{|c|c|c|c|l}
            \cline{1-4}
            Errors & Dufort-Frankel & Laasonen & Crank-Nicholson &  \\ \cline{1-4}
            1-norm & 0,56\%         & 1,72\%   & 1,26\%          &  \\ \cline{1-4}
            2-norm & 24,43\%        & 2,35\%   & 1,61\%          &  \\ \cline{1-4}
            $\infty$-norm  & 1,18\%         & 2,62\%   & 1,61\%          &  \\ \cline{1-4}
            \end{tabular}
        \end{table}
        We observe that for the 1-norm and the $\infty$-norm, Dufort-Frankel method is the most accurate, 
        followed by the Crank-Nicholson method then by the Laasonen method. Let see the evolution of the error
        while time is increased.
        \begin{figure}[H]
            \centering
            \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{t02.png}
                \caption{t = 0,2h}
            \end{subfigure}
            \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{t03.png}
                \caption{t = 0,3h}
            \end{subfigure}
            \\
            \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{t04.png}
                \caption{t = 0,4h}
            \end{subfigure}
            \begin{subfigure}[b]{0.45\textwidth}
                \includegraphics[width=\textwidth]{t05.png}
                \caption{t = 0,5h}
            \end{subfigure}
            \caption{Results with differents schemes at different times}
        \end{figure}
        \begin{table}[H]
            \centering
            \caption{Errors for different schemes at different times}
            \begin{tabular}{|c|c|c|c|l}
            \cline{1-4}
            Errors & Dufort-Frankel & Laasonen & Crank-Nicholson &  \\ \cline{1-4}
            \multicolumn{4}{|c|}{t = 0,2h}                       &  \\ \cline{1-4}
            1-norm & 0,37\%         & 1,05\%   & 0,80\%          &  \\ \cline{1-4}
            2-norm & 14,11\%        & 1,25\%   & 0,87\%          &  \\ \cline{1-4}
            $\infty$-norm  & 0,63\%         & 1,28\%   & 0,81\%          &  \\ \cline{1-4}
            \multicolumn{4}{|c|}{t = 0,3h}                       &  \\ \cline{1-4}
            1-norm & 0,27\%         & 0,77\%   & 0,60\%          &  \\ \cline{1-4}
            2-norm & 10,50\%        & 0,84\%   & 0,62\%          &  \\ \cline{1-4}
            $\infty$-norm  & 0,42\%         & 0,83\%   & 0,54\%          &  \\ \cline{1-4}
            \multicolumn{4}{|c|}{t = 0,4h}                       &  \\ \cline{1-4}
            1-norm & 0,22\%         & 0,64\%   & 0,49\%          &  \\ \cline{1-4}
            2-norm & 8,84\%        & 0,67\%   & 0,52\%          &  \\ \cline{1-4}
            $\infty$-norm  & 0,34\%         & 0,60\%   & 0,43\%          &  \\ \cline{1-4}
            \multicolumn{4}{|c|}{t = 0,5h}                       &  \\ \cline{1-4}
            1-norm & 0,18\%         & 0,55\%   & 0,42\%          &  \\ \cline{1-4}
            2-norm & 7,86\%        & 0,58\%   & 0,45\%          &  \\ \cline{1-4}
            $\infty$-norm  & 0,32\%         & 0,51\%   & 0,41\%          &  \\ \cline{1-4}
            \end{tabular}
        \end{table}

        We observe that the error is globally decreasing as time increase. The most accurate methods appears to 
        be the Crank-Nicholson method, then the Laasonen method.
        \subsection{Laasonen method : effect of the step time}

    % Discussion
    \newpage
    \section{Discussion}

    % Future work
    \newpage
    \section{Future work}

    % Conclusion
    \newpage
    \section{Conclusion}

    % Aknowledgments
    \newpage
    \section{Aknowledgments}

    % References
    \newpage
    \section{References}

    % Appendices
    \newpage
    \section{Appendices}
\end{document}